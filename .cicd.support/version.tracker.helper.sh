#!/bin/bash


# ###########################################################################
#
#                                    XXXXX
#
# ###########################################################################

printf "\033[0;32mLoading Version Tracking Helper script...\033[0m\n"

#Reads the version stored in the version file.
#All lines that starts with '#' are ignored. reads first non-commented line
#  REQUIRES: Version file to exist
#  INPUT: File name storing current version
#  RETURN: Version found in file
function get_tag_version {
    TAG_FILE="$1"
    if [ ! -f "$TAG_FILE" ]; then
        echo "ERROR: File $TAG_FILE does not exist. Aborting..."
        exit 1;
    fi

    # First non-commented line
    first_line="$(grep -m 1 -v -e "#" $TAG_FILE)"
    read_version=$first_line
    return 0
}

#Calculates a new version based on branch name
#Branch name needs to start with either mayor/feature/features/bugfix/bugfixes followed by a description
#Example: feature/added-unittest
#  REQUIRES: Version file to exist
#  INPUT: File name storing current version
#  INPUT: branchName: current branch name to process
#  OUTPUT: new_version contains the new calculated version
#  RETURN: 0 if success, non-zero otherwise
function calculate_new_tag_version {
    TAG_FILE="$1"
    curr_branch_name="$2"

    get_tag_version "$TAG_FILE"
    prev_version=$read_version
    # Remove v in vX.X.X
    last_version00=$(echo $prev_version | sed 's/v//' )
    # Remove leading/trailing white spaces
    last_version=$(echo $last_version00 | sed 's/ *$//g')
    #Tokenize
    OLDIFS=$IFS
    IFS='.'; only_version=( $last_version ); 
    IFS=$OLDIFS
 
    MAYOR=${only_version[0]}
    MINOR=${only_version[1]}
    PATCH=${only_version[2]}
    echo "Version is >$MAYOR< : >$MINOR< : >$PATCH<"    

    if [[ $curr_branch_name == mayor/* ]]; then
        MAYOR=$((MAYOR+1))
    elif [[ $curr_branch_name == feature/* ]] || [[ $curr_branch_name == features/* ]]; then
        MINOR=$((MINOR+1))
    elif [[ $curr_branch_name == bugfix/* ]] || [[ $curr_branch_name == bugfixes/* ]]; then
        PATCH=$((PATCH+1))
    else
        echo "ERROR: Branch name \"$curr_branch_name\" not recognize. It need to start with \"mayor/\", \"feature/\" or \"bugfix/\". Aborting..."
        exit 1;
    fi

    new_version="v$MAYOR.$MINOR.$PATCH"

    #Report
    echo "REPORT: File \"$TAG_FILE\" updated from $prev_version to $new_version"

    return 0;
}

#Updates file tracking versioning
#Currently it manages three file. Main file contains only the current version, 
#.old contains list of versions and .history contains version+date+message history
#  INPUT: File name storing current version
#  INPUT: New version being generated
#  INPUT: Message
#  OUTPUT: 3 version tracking files are updated
#  RETURN: 0 if success, non-zero otherwise
function update_version_tracking {
    TAG_FILE="$1"

    if [ -z "$2" ]; then
        echo "ERROR: You need to provide the new version value to update history and internal version tracker. Aborting..."
        exit 1;
    fi
    
    new_version=$2
    msg=""
    [ -n "$3" ] && msg="$3"
    curr_date="$(date)"

    # Append new version to file tracker of published versions
    echo "$new_version"  >> $TAG_FILE.old
    # Append version and message to history to upload to static site    
    echo "* $new_version : $cur_date : $msg"  >> $TAG_FILE.history
    # Re-create the $TAG_FILEn file
    echo "# Do not edit this file" > $TAG_FILE
    echo "# Semantic versioning: v{MAYOR}.{MINOR}.{PATCH}" >> $TAG_FILE
    echo "$new_version" >> $TAG_FILE
    return 0;
}