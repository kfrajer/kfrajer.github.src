#!/bin/bash

## INSTRUCTIONS
## To run: `./gh-deploy.sh {folder} "{msg}"` 
## You might need to execute this first: `sed -i -e 's/\r$//' gh-deploy.sh`
## Parameters:
##   folder: Folder to output built pages. Default is published
##   msg: Message to add to commit. Use quotes if msg has any spaces
##

# If a command fails then the deploy stops
set -e
set -x

#Reads the version stored in the version file.
#All lines that starts with '#' are ignored. reads first non-commented line
#  REQUIRES: Version file to exist
#  INPUT: File name storing current version
#  RETURN: Version found in file
function get_tag_version {
    TAG_FILE="$1"
    if [ ! -f "$TAG_FILE" ]; then
        echo "ERROR: File $TAG_FILE does not exist. Aborting..."
        exit 1;
    fi

    # First non-commented line
    first_line="$(grep -m 1 -v -e "#" $TAG_FILE)"
    return 0
}

#Updates version file based on branch name
#Branch name needs to start with either mayor/feature/features/bugfix/bugfixes followed by a description
#Example: feature/added-unittest
#  REQUIRES: Version file to exist
#  INPUT: File name storing current version
#  INPUT: branchName: current branch name to process
#  RETURN: 0 if success, non-zero otherwise
function update_tag_version {
    TAG_FILE="$1"
    curr_branch_name="$2"

    get_tag_version "$TAG_FILE"
    prev_version=$first_line
    # Remove v in vX.X.X
    last_version00=$(echo $prev_version | sed 's/v//' )
    # Remove leading/trailing white spaces
    last_version=$(echo $last_version00 | sed 's/ *$//g')
    #Tokenize
    OLDIFS=$IFS
    IFS='.'; only_version=( $last_version ); 
    IFS=$OLDIFS
 
    MAYOR=${only_version[0]}
    MINOR=${only_version[1]}
    PATCH=${only_version[2]}
    echo "Version is >$MAYOR< : >$MINOR< : >$PATCH<"    

    if [[ $curr_branch_name == mayor/* ]]; then
        MAYOR=$((MAYOR+1))
    elif [[ $curr_branch_name == feature/* ]] || [[ $curr_branch_name == features/* ]]; then
        MINOR=$((MINOR+1))
    elif [[ $curr_branch_name == bugfix/* ]] || [[ $curr_branch_name == bugfixes/* ]]; then
        PATCH=$((PATCH+1))
    else
        echo "ERROR: Branch name \"$curr_branch_name\" not recognize. It need to start with \"mayor/\", \"feature/\" or \"bugfix/\". Aborting..."
        exit 1;
    fi

    new_version="v$MAYOR.$MINOR.$PATCH"
    # Append to old file
    cat $TAG_FILE >> $TAG_FILE.old
    echo "# Do not edit this file" > $TAG_FILE
    echo "# Semantic versioning: v{MAYOR}.{MINOR}.{PATCH}" >> $TAG_FILE
    echo "$new_version" >> $TAG_FILE

    #Report
    echo "REPORT: File \"$TAG_FILE\" updated from $prev_version to $new_version"

    return 0;
}

# ###########################################################################
#
#                                    XXXXX
#
# ###########################################################################

printf "\033[0;32mDeploying updates to GitHub...\033[0m\n"

FOLDER2PUBLISH=published
MSG="Rebuilding site $(date)"
branchName=$(git rev-parse --abbrev-ref HEAD)
VERSION_FILE_TRACKER="../.repo_version"

if [ "$branchName" = master ]; then
    echo "ERROR: Your are in master. Deploy manually. Aborting..."
    exit 1;
fi

[ -n "$1" ] && FOLDER2PUBLISH="$1"
[ -n "$2" ] && MSG="$2"

# Build the project.
hugo -d $FOLDER2PUBLISH

???

git push --set-upstream origin $branchName

# Go To Public folder
cd $FOLDER2PUBLISH

## Copy site readme file to folder
cp -f ../README.site.md README.md
# Instruct Github this static content is not using jekyll
[ ! -f ".nojekyll"  ] && touch .nojekyll

# Add changes to git.
git add .

git commit -m "$MSG"

update_tag_version "$VERSION_FILE_TRACKER" $branchName
get_tag_version "$VERSION_FILE_TRACKER"
TAGVER=$first_line
if [ -n "$TAGVER" ]; then
    git tag -a "$TAGVER" -m "$MSG"
fi

# Push source and build repos.
git push origin master --follow-tags

# Revert to initial directory
cd ..

printf "\033[0;32mDeploying updates to GitHub...\033[0;33mDONE\033[0m\n"

set +x
